#include <FastLED.h>

// FONTS: https://create.arduino.cc/projecthub/SAnwandter1/programming-8x8-led-matrix-23475a for 8x8 so some modification is needed

byte ALL[] = {B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111};
byte EX[] = {B00000000,B00010000,B00010000,B00010000,B00010000,B00000000,B00010000};
byte A[] = {B00011000,B00111100,B01100110,B01100110,B01111110,B01100110,B01100110};
byte B[] = {B01111001,B01001000,B01001000,B01110000,B01001000,B01000100,B01000100};
byte C[] = {B00000000,B00011110,B00100000,B01000000,B01000000,B01000000,B00100000};
byte D[] = {B00000000,B00111000,B00100100,B00100010,B00100010,B00100100,B00111000};
byte E[] = {B01111100,B01100000,B01100000,B01111000,B01100000,B01100000,B01111100};
byte F[] = {B00000000,B00111100,B00100000,B00111000,B00100000,B00100000,B00100000};
byte G[] = {B00000000,B00111110,B00100000,B00100000,B00101110,B00100010,B00111110};
byte H[] = {B00000000,B00100100,B00100100,B00111100,B00100100,B00100100,B00100100};
byte I[] = {B00000000,B00111000,B00010000,B00010000,B00010000,B00010000,B00111000};
byte J[] = {B00000000,B00011100,B00001000,B00001000,B00001000,B00101000,B00111000};
byte K[] = {B11000100,B11001000,B11010000,B11100000,B11010000,B11001000,B11000100};
byte L[] = {B00000000,B00100000,B00100000,B00100000,B00100000,B00100000,B00111100};
byte M[] = {B10000010,B11000110,B11101110,B11010110,B11000110,B11000110,B11000110};
byte N[] = {B00000000,B00100010,B00110010,B00101010,B00100110,B00100010,B00000000};
byte O[] = {B00111000,B11000110,B11000110,B11000110,B11000110,B11000110,B00111000};
byte P[] = {B01111000,B01100100,B01100100,B01111000,B01100000,B01100000,B01100000};
byte Q[] = {B00000000,B00111100,B01000010,B01000010,B01000010,B01000110,B00111110};
byte R[] = {B11110000,B11001000,B11000100,B11000100,B11111000,B11000100,B11000100};
byte S[] = {B00000000,B00111100,B00100000,B00111100,B00000100,B00000100,B00111100};
byte T[] = {B00000000,B01111100,B00010000,B00010000,B00010000,B00010000,B00010000};
byte U[] = {B11000110,B11000110,B11000110,B11000110,B11000110,B00101000,B00010000};
byte V[] = {B00000000,B00100010,B00100010,B00100010,B00010100,B00010100,B00001000};
byte W[] = {B00000000,B10000010,B10010010,B01010100,B01010100,B00101000,B00000000};
byte X[] = {B00000000,B01000010,B00100100,B00011000,B00011000,B00100100,B01000010};
byte Y[] = {B00000000,B01000100,B00101000,B00010000,B00010000,B00010000,B00010000};
byte Z[] = {B00000000,B00111100,B00000100,B00001000,B00010000,B00100000,B00111100};


#define NUM_LEDS 7*8
#define DATA_PIN 13
#define DELAY 1000

CRGB leds[NUM_LEDS];
uint8_t max_bright = 40; 

bool is_bit_set(unsigned value, unsigned bitindex){
//https://stackoverflow.com/questions/127027/how-can-i-check-my-byte-flag-verifying-that-a-specific-bit-is-at-1-or-0#127062
    return (value & (1 << bitindex)) != 0;
}

void setup(){
   delay(1000);                          // Power-up safety delay.
   FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);
   FastLED.setBrightness( max_bright );
}

void loop() {
    drawMatrix(M);
    delay( DELAY );
     drawMatrix(A);
    delay( DELAY );
    drawMatrix(R);
    delay( DELAY );
    drawMatrix(K);
    delay( DELAY );
    drawMatrix(U);
    delay( DELAY );
    drawMatrix(O);
    delay( DELAY );
    drawMatrix(P);
    delay( DELAY );
    drawMatrix(E);
    delay( DELAY );

    for(int brightness = max_bright; brightness > 0; brightness-=2) { 
      FastLED.setBrightness( brightness );
      FastLED.delay(1);
    }
    FastLED.clear();
    FastLED.delay(5000);
}


bool  drawMatrix(byte letter[]){ 
  FastLED.clear();
  FastLED.setBrightness( max_bright );
  for (int i = 0; i < 7; i++){
    for (unsigned int j = 0; j < 8; j++){
        if (is_bit_set(letter[i], 7-j)){
          //Need to reverse the bit
            leds[i*8+j] = CRGB::Blue;
        }
    }
  }
  FastLED.show();
  return true;
} 
 
